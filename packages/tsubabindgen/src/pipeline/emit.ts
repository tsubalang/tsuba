import { relative, resolve } from "node:path";

import type {
  GenerateBindings,
  ParsedModule,
  RustField,
  RustType,
  SkipIssueReportEntry,
} from "./common.js";
import {
  compareText,
  fail,
  isJsKeyword,
  isSelfLike,
  MARKER_TYPES,
  normalizePath,
  stableIdFromText,
} from "./common.js";

export function moduleSpecifier(pkg: string, parts: readonly string[]): string {
  if (parts.length === 0) return `${pkg}/index.js`;
  return `${pkg}/${parts.join("/")}.js`;
}

export function moduleJsName(parts: readonly string[]): string {
  return parts.length === 0 ? "index.js" : `${parts.join("/")}.js`;
}

export function moduleDtsName(parts: readonly string[]): string {
  return parts.length === 0 ? "index.d.ts" : `${parts.join("/")}.d.ts`;
}

export function rustPath(crateName: string, parts: readonly string[]): string {
  return [crateName, ...parts].join("::");
}

function collectMarkerTypes(modules: readonly ParsedModule[]): string[] {
  const tokens = new Set<string>();
  const emitText = (text: string): void => {
    const matches = text.match(/\b[A-Za-z_][A-Za-z0-9_]*\b/g) ?? [];
    for (const token of matches) {
      if (MARKER_TYPES.has(token)) tokens.add(token);
    }
  };
  for (const module of modules) {
    for (const c of module.consts) emitText(c.type);
    for (const s of module.structs) {
      for (const f of s.fields) emitText(f.type);
      if (s.constructorMethod) {
        emitText(s.constructorMethod.returnType);
        for (const p of s.constructorMethod.params) emitText(p.type);
      }
      for (const m of s.methods) {
        emitText(m.returnType);
        for (const p of m.params) emitText(p.type);
      }
    }
    for (const e of module.enums) {
      for (const v of e.variants) {
        for (const f of v.fields) emitText(f.type);
      }
    }
    for (const t of module.traits) {
      for (const st of t.superTraits) emitText(st);
      for (const m of t.methods) {
        emitText(m.returnType);
        const first = m.params.at(0);
        if (first?.name === "&self") emitText("ref<this>");
        if (first?.name === "&mut self") emitText("mutref<this>");
        for (const p of m.params) emitText(p.type);
      }
    }
    for (const f of module.functions) {
      if (f.kind === "macro") emitText("Macro Tokens");
      if (f.kind === "attr_macro") emitText("AttrMacro Attr Tokens");
      if (f.kind === "derive") emitText("DeriveMacro");
      emitText(f.returnType);
      for (const p of f.params) emitText(p.type);
    }
  }
  return [...tokens].sort((a, b) => compareText(a, b)).filter((name) => !isJsKeyword(name));
}

export function emitDts(module: ParsedModule): string {
  const lines: string[] = [];
  lines.push("// Generated by tsubabindgen (v0)", "");
  lines.push(...module.consts.map((c) => `export const ${c.name}: ${c.type};`));

  for (const e of module.enums) {
    const enumTypeParams = e.typeParams.length > 0 ? `<${e.typeParams.join(", ")}>` : "";
    lines.push(`export declare class ${e.name}${enumTypeParams} {`);
    lines.push("  private constructor();");
    for (const v of e.variants) {
      if (v.fields.length === 0) {
        lines.push(`  static readonly ${v.name}: ${e.name}${enumTypeParams};`);
        continue;
      }
      const args = v.fields.map((f) => `${f.name}: ${f.type}`).join(", ");
      lines.push(`  static ${v.name}(${args}): ${e.name}${enumTypeParams};`);
    }
    lines.push("}");
    lines.push("");
  }

  for (const t of module.traits) {
    const traitTypeParams = t.typeParams.length > 0 ? `<${t.typeParams.join(", ")}>` : "";
    const extendsClause = t.superTraits.length > 0 ? ` extends ${t.superTraits.join(", ")}` : "";
    lines.push(`export interface ${t.name}${traitTypeParams}${extendsClause} {`);
    for (const m of t.methods) {
      const methodTypeParams = m.typeParams.length > 0 ? `<${m.typeParams.join(", ")}>` : "";
      const params = [...m.params];
      const first = params.at(0);
      const hasSelf = isSelfLike(first?.name ?? "");
      const thisParam =
        first?.name === "&mut self"
          ? "this: mutref<this>"
          : first?.name === "&self"
            ? "this: ref<this>"
            : first?.name === "self"
              ? "this: this"
              : undefined;
      const restParams = hasSelf ? params.slice(1) : params;
      const args = [...(thisParam ? [thisParam] : []), ...restParams.map((p) => `${p.name}: ${p.type}`)].join(", ");
      lines.push(`  ${m.name}${methodTypeParams}(${args}): ${m.returnType};`);
    }
    lines.push("}");
    lines.push("");
  }

  for (const s of module.structs) {
    const structTypeParams = s.typeParams.length > 0 ? `<${s.typeParams.join(", ")}>` : "";
    lines.push(`export declare class ${s.name}${structTypeParams} {`);
    for (const field of s.fields) lines.push(`  ${field.name}: ${field.type};`);
    if (s.constructorMethod) {
      const ctorTypeParams =
        s.constructorMethod.typeParams.length > 0 ? `<${s.constructorMethod.typeParams.join(", ")}>` : "";
      lines.push(
        `  constructor${ctorTypeParams}(${s.constructorMethod.params.map((p) => `${p.name}: ${p.type}`).join(", ")});`
      );
    }
    for (const m of s.methods) {
      const methodTypeParams = m.typeParams.length > 0 ? `<${m.typeParams.join(", ")}>` : "";
      const args = m.params.map((p) => `${p.name}: ${p.type}`).join(", ");
      if (m.kind === "instance") {
        lines.push(`  ${m.name}${methodTypeParams}(${args}): ${m.returnType};`);
      } else {
        lines.push(`  static ${m.name}${methodTypeParams}(${args}): ${m.returnType};`);
      }
    }
    lines.push("}");
    lines.push("");
  }

  for (const f of module.functions) {
    if (f.kind === "derive") {
      lines.push(`export const ${f.name}: DeriveMacro;`);
      continue;
    }
    if (f.kind === "macro") {
      lines.push(`export const ${f.name}: Macro<(...args: readonly Tokens[]) => Tokens>;`);
      continue;
    }
    if (f.kind === "attr_macro") {
      lines.push(`export const ${f.name}: AttrMacro<(...args: readonly Tokens[]) => Attr>;`);
      continue;
    }
    const fnTypeParams = f.typeParams.length > 0 ? `<${f.typeParams.join(", ")}>` : "";
    const args = f.params.map((p) => `${p.name}: ${p.type}`).join(", ");
    lines.push(`export function ${f.name}${fnTypeParams}(${args}): ${f.returnType};`);
  }

  const markerTypes = collectMarkerTypes([module]).filter((name) => !name.startsWith("__"));
  if (markerTypes.length > 0) {
    lines.unshift(`import type { ${markerTypes.join(", ")} } from "@tsuba/core/types.js";`, "");
  }

  return lines.join("\n").trimEnd() + "\n";
}

export function makePackageJson(packageName: string, version: string, entrypoints: readonly string[]): string {
  const exports: Record<string, { types: string; default: string }> = {
    ".": { types: "./index.d.ts", default: "./index.js" },
  };
  for (const entry of entrypoints) {
    exports[`./${entry}`] = {
      types: `./${entry.replace(/\.js$/g, ".d.ts")}`,
      default: `./${entry}`,
    };
  }
  const files = ["index.d.ts", "index.js", "tsuba.bindings.json", "README.md", "package.json"];
  for (const entry of entrypoints) {
    files.push(entry);
    files.push(entry.replace(/\.js$/g, ".d.ts"));
  }
  const pkg = {
    name: packageName,
    version,
    type: "module",
    main: "./index.js",
    types: "./index.d.ts",
    exports,
    files,
  };
  return `${JSON.stringify(pkg, null, 2)}\n`;
}

export function moduleForRustPath(modules: readonly ParsedModule[], crateName: string, rustPathName: string): ParsedModule {
  if (rustPathName === crateName) {
    const root = modules.find((m) => m.moduleParts.length === 0);
    if (!root) fail(`Could not find root module for rust path ${rustPathName}.`);
    return root;
  }
  const targetParts = rustPathName.slice(crateName.length + 2).split("::");
  const target = modules.find((m) => m.moduleParts.join("::") === targetParts.join("::"));
  if (!target) fail(`Could not find module for ${rustPathName}.`);
  return target;
}

function classifySkipIssue(kind: string): { readonly phase: "extract" | "resolve" | "emit"; readonly code: string } {
  switch (kind) {
    case "parse":
      return { phase: "extract", code: "TBB1000" };
    case "reexport":
      return { phase: "resolve", code: "TBB2000" };
    case "generic":
      return { phase: "emit", code: "TBB3000" };
    case "param":
      return { phase: "emit", code: "TBB3001" };
    case "type":
      return { phase: "emit", code: "TBB3002" };
    case "trait":
      return { phase: "emit", code: "TBB3003" };
    case "trait-method":
      return { phase: "emit", code: "TBB3004" };
    case "impl":
      return { phase: "emit", code: "TBB3005" };
    case "enum":
      return { phase: "emit", code: "TBB3006" };
    case "struct":
      return { phase: "emit", code: "TBB3007" };
    case "macro":
      return { phase: "emit", code: "TBB3008" };
    default:
      return { phase: "emit", code: "TBB3999" };
  }
}

function genericSuffix(typeParams: readonly string[]): string {
  if (typeParams.length === 0) return "";
  return `<${typeParams.join(",")}>`;
}

function fnSignature(
  name: string,
  typeParams: readonly string[],
  params: readonly RustField[],
  returnType: RustType
): string {
  const args = params.map((p) => `${p.name}:${p.type}`).join(",");
  return `${name}${genericSuffix(typeParams)}(${args})->${returnType}`;
}

export function collectStableSymbols(
  modules: readonly ParsedModule[],
  crateName: string
): Record<string, { readonly kind: string; readonly stableId: string }> {
  const rows: Array<{ key: string; kind: string }> = [];
  const push = (kind: string, key: string): void => {
    rows.push({ kind, key });
  };

  for (const module of modules) {
    const moduleRustPath = rustPath(crateName, module.moduleParts);
    for (const c of module.consts) push("const", `${moduleRustPath}::const:${c.name}:${c.type}`);
    for (const f of module.functions) {
      push(f.kind, `${moduleRustPath}::fn:${f.kind}:${fnSignature(f.name, f.typeParams, f.params, f.returnType)}`);
    }
    for (const e of module.enums) {
      const enumKey = `${moduleRustPath}::enum:${e.name}${genericSuffix(e.typeParams)}`;
      push("enum", enumKey);
      for (const v of e.variants) {
        const variantKey = `${enumKey}::variant:${v.name}`;
        push("variant", variantKey);
        for (const field of v.fields) {
          push("variant_field", `${variantKey}::field:${field.name}:${field.type}`);
        }
      }
    }
    for (const s of module.structs) {
      const structKey = `${moduleRustPath}::struct:${s.name}${genericSuffix(s.typeParams)}`;
      push("struct", structKey);
      for (const field of s.fields) push("field", `${structKey}::field:${field.name}:${field.type}`);
      if (s.constructorMethod) {
        push(
          "method",
          `${structKey}::method:${s.constructorMethod.kind}:${fnSignature(
            s.constructorMethod.name,
            s.constructorMethod.typeParams,
            s.constructorMethod.params,
            s.constructorMethod.returnType
          )}`
        );
      }
      for (const method of s.methods) {
        push(
          "method",
          `${structKey}::method:${method.kind}:${fnSignature(
            method.name,
            method.typeParams,
            method.params,
            method.returnType
          )}`
        );
      }
    }
    for (const t of module.traits) {
      const traitKey = `${moduleRustPath}::trait:${t.name}${genericSuffix(t.typeParams)}`;
      push("trait", traitKey);
      if (t.superTraits.length > 0) push("trait_super", `${traitKey}::super:${t.superTraits.join("+")}`);
      for (const method of t.methods) {
        push(
          "trait_method",
          `${traitKey}::method:${fnSignature(method.name, method.typeParams, method.params, method.returnType)}`
        );
      }
    }
  }

  rows.sort((a, b) => {
    const byKey = compareText(a.key, b.key);
    if (byKey !== 0) return byKey;
    return compareText(a.kind, b.kind);
  });

  const symbols: Record<string, { readonly kind: string; readonly stableId: string }> = {};
  for (const row of rows) {
    const prev = symbols[row.key];
    if (prev) {
      if (prev.kind !== row.kind) {
        fail(`Stable symbol key collision for ${row.key}: ${prev.kind} vs ${row.kind}.`);
      }
      continue;
    }
    symbols[row.key] = {
      kind: row.kind,
      stableId: stableIdFromText(`${row.kind}\u0000${row.key}`),
    };
  }
  return symbols;
}

export function collectSkipIssues(modules: readonly ParsedModule[], crateRoot?: string): readonly SkipIssueReportEntry[] {
  const normalizeIssueFile = (value: string): string => {
    const normalized = normalizePath(value);
    if (!crateRoot) return normalized;
    if (!normalized.startsWith("/") && !/^[A-Za-z]:\//.test(normalized)) return normalized;
    const rel = normalizePath(relative(crateRoot, resolve(value)));
    if (rel.length === 0 || rel.startsWith("../")) return normalized;
    return rel;
  };
  const seen = new Set<string>();
  const out: SkipIssueReportEntry[] = [];
  for (const module of modules) {
    for (const issue of module.issues) {
      const file = normalizeIssueFile(issue.file);
      const key = `${file}\u0000${issue.kind}\u0000${issue.snippet}\u0000${issue.reason}`;
      if (seen.has(key)) continue;
      seen.add(key);
      const classification = classifySkipIssue(issue.kind);
      out.push({
        ...issue,
        file,
        phase: classification.phase,
        code: classification.code,
        stableId: stableIdFromText(`${classification.code}\u0000${key}`),
      });
    }
  }
  out.sort((a, b) => {
    const byFile = compareText(a.file, b.file);
    if (byFile !== 0) return byFile;
    const byKind = compareText(a.kind, b.kind);
    if (byKind !== 0) return byKind;
    const bySnippet = compareText(a.snippet, b.snippet);
    if (bySnippet !== 0) return bySnippet;
    return compareText(a.reason, b.reason);
  });
  return out;
}

export function buildBindingsManifest(args: {
  readonly crateName: string;
  readonly cratePackage: string;
  readonly crateVersion: string;
  readonly bundleCrate: boolean;
  readonly modulesMap: Record<string, string>;
  readonly stableSymbols: Record<string, { readonly kind: string; readonly stableId: string }>;
}): GenerateBindings {
  return {
    schema: 1,
    kind: "crate",
    crate: {
      name: args.crateName,
      package: args.cratePackage,
      ...(args.bundleCrate ? { path: "./crate" } : { version: args.crateVersion }),
    },
    modules: args.modulesMap,
    symbols: args.stableSymbols,
  };
}
