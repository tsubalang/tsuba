import { createHash } from "node:crypto";

export const MANIFEST_TEMPLATE = `// Generated by tsubabindgen (v0)
throw new Error("This package is type-only and intended to be compiled by Tsuba, not executed in Node.");
`;

const JS_KEYWORDS = new Set([
  "class",
  "delete",
  "default",
  "namespace",
  "return",
  "new",
  "super",
  "static",
  "var",
  "const",
  "let",
]);

export const MARKER_TYPES = new Set([
  "bool",
  "f16",
  "bf16",
  "f32",
  "f64",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "isize",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "usize",
  "String",
  "Str",
  "Slice",
  "ArrayN",
  "Option",
  "Result",
  "ref",
  "mutref",
  "refLt",
  "mutrefLt",
  "mut",
  "Tokens",
  "Attr",
  "DeriveMacro",
  "Macro",
]);

export type GenerateOptions = {
  readonly manifestPath: string;
  readonly outDir: string;
  readonly packageName?: string;
  readonly bundleCrate: boolean;
};

export type GenerateBindings = {
  readonly schema: number;
  readonly kind: "crate";
  readonly crate: {
    readonly name: string;
    readonly package: string;
    readonly version?: string;
    readonly path?: string;
  };
  readonly modules: Record<string, string>;
  readonly symbols: Record<string, { readonly kind: string; readonly stableId: string }>;
};

export type RustType = string;

export type RustField = {
  readonly kind: "field";
  readonly name: string;
  readonly type: RustType;
};

export type RustFunctionKind = "fn" | "macro" | "attr_macro" | "derive";

export type RustFunction = {
  readonly kind: RustFunctionKind;
  readonly name: string;
  readonly typeParams: readonly string[];
  readonly params: readonly RustField[];
  readonly returnType: RustType;
};

export type RustMethodKind = "constructor" | "instance" | "static";

export type RustMethod = {
  readonly name: string;
  readonly kind: RustMethodKind;
  readonly typeParams: readonly string[];
  readonly params: readonly RustField[];
  readonly returnType: RustType;
};

export type RustTraitMethod = {
  readonly name: string;
  readonly typeParams: readonly string[];
  readonly params: readonly RustField[];
  readonly returnType: RustType;
};

export type RustTrait = {
  readonly name: string;
  readonly typeParams: readonly string[];
  readonly superTraits: readonly RustType[];
  readonly methods: readonly RustTraitMethod[];
};

export type RustReexport = {
  readonly name: string;
  readonly source: string;
};

export type RustStruct = {
  readonly name: string;
  readonly typeParams: readonly string[];
  readonly fields: readonly RustField[];
  methods: RustMethod[];
  constructorMethod?: RustMethod;
};

export type RustEnum = {
  readonly name: string;
  readonly typeParams: readonly string[];
  readonly variants: readonly {
    readonly name: string;
    readonly fields: readonly RustField[];
  }[];
};

export type ParsedModule = {
  specName: string;
  readonly source: string;
  moduleParts: string[];
  readonly consts: RustField[];
  enums: RustEnum[];
  structs: RustStruct[];
  traits: RustTrait[];
  functions: RustFunction[];
  reexports: RustReexport[];
  pendingMethods: Map<string, RustFunction[]>;
  issues: SkipIssue[];
};

export type ExtractedPendingMethods = {
  readonly target: string;
  readonly methods: readonly RustFunction[];
};

export type ExtractedModule = {
  readonly file: string;
  readonly parts: readonly string[];
  readonly consts: readonly RustField[];
  readonly enums: readonly RustEnum[];
  readonly structs: readonly RustStruct[];
  readonly traits: readonly RustTrait[];
  readonly functions: readonly RustFunction[];
  readonly reexports?: readonly {
    readonly name: string;
    readonly source: string;
  }[];
  readonly pendingMethods: readonly ExtractedPendingMethods[];
  readonly issues: readonly SkipIssue[];
};

export type ExtractedOutput = {
  readonly schema: number;
  readonly modules: readonly ExtractedModule[];
};

export type SkipIssue = {
  readonly file: string;
  readonly kind: string;
  readonly snippet: string;
  readonly reason: string;
};

export type SkipIssueReportEntry = SkipIssue & {
  readonly phase: "extract" | "resolve" | "emit";
  readonly code: string;
  readonly stableId: string;
};

export function fail(message: string): never {
  throw new Error(message);
}

export function normalizePath(path: string): string {
  return path.replaceAll("\\", "/");
}

export function compareText(a: string, b: string): number {
  if (a === b) return 0;
  return a < b ? -1 : 1;
}

export function stableIdFromText(text: string): string {
  return createHash("sha256").update(text).digest("hex").slice(0, 16);
}

export function normalizeTypeText(raw: string): string {
  return raw.trim().replaceAll(/\s+/g, " ");
}

export function normalizeIdentifier(raw: string): string {
  const trimmed = raw.trim();
  return JS_KEYWORDS.has(trimmed) ? `${trimmed}_` : trimmed;
}

export function isJsKeyword(raw: string): boolean {
  return JS_KEYWORDS.has(raw);
}

export function splitTopLevel(text: string, sep: string): string[] {
  const out: string[] = [];
  let depth = 0;
  let quote: string | null = null;
  let start = 0;
  for (let i = 0; i < text.length; i += 1) {
    const ch = text[i]!;
    if (quote !== null) {
      if (ch === quote && text[i - 1] !== "\\") quote = null;
      continue;
    }
    if (ch === `"` || ch === "'" || ch === "`") {
      quote = ch;
      continue;
    }
    if (ch === "<" || ch === "(" || ch === "[" || ch === "{") {
      depth += 1;
      continue;
    }
    if (ch === ">" || ch === ")" || ch === "]" || ch === "}") {
      if (depth > 0) depth -= 1;
      continue;
    }
    if (depth === 0 && ch === sep) {
      const seg = text.slice(start, i).trim();
      if (seg.length > 0) out.push(seg);
      start = i + 1;
    }
  }
  const tail = text.slice(start).trim();
  if (tail.length > 0) out.push(tail);
  return out;
}

export function findMatching(text: string, openAt: number, open: string, close: string): number {
  let depth = 0;
  let quote: string | null = null;
  for (let i = openAt; i < text.length; i += 1) {
    const ch = text[i]!;
    if (quote !== null) {
      if (ch === quote && text[i - 1] !== "\\") quote = null;
      continue;
    }
    if (ch === `"` || ch === "'" || ch === "`") {
      quote = ch;
      continue;
    }
    if (ch === open) {
      depth += 1;
      continue;
    }
    if (ch === close) {
      depth -= 1;
      if (depth === 0) return i;
    }
  }
  return -1;
}

export function isSelfLike(name: string): boolean {
  return name === "self" || name === "&self" || name === "&mut self";
}

export function skipWs(text: string, start: number): number {
  let i = start;
  while (i < text.length) {
    const ch = text.charCodeAt(i);
    if (ch === 10 || ch === 13 || ch === 32 || ch === 9) {
      i += 1;
      continue;
    }
    break;
  }
  return i;
}
