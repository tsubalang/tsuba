import { spawnSync } from "node:child_process";
import {
  cpSync,
  mkdirSync,
  readdirSync,
  rmSync,
  statSync,
  writeFileSync,
} from "node:fs";
import { dirname, join, resolve } from "node:path";

import { collectModules } from "./pipeline/extract.js";
import {
  buildBindingsManifest,
  collectSkipIssues,
  collectStableSymbols,
  emitDts,
  makePackageJson,
  moduleDtsName,
  moduleForRustPath,
  moduleJsName,
  moduleSpecifier,
  rustPath,
} from "./pipeline/emit.js";
import { MANIFEST_TEMPLATE, type GenerateBindings, type GenerateOptions, compareText, fail } from "./pipeline/common.js";
import { applyReexports, attachMethods } from "./pipeline/resolve.js";

export type { GenerateOptions, GenerateBindings } from "./pipeline/common.js";

function ensureDir(path: string): void {
  mkdirSync(path, { recursive: true });
}

function copyDir(src: string, dst: string): void {
  ensureDir(dst);
  for (const entry of readdirSync(src)) {
    if (entry === ".git" || entry === "target") continue;
    const from = join(src, entry);
    const to = join(dst, entry);
    const st = statSync(from);
    if (st.isDirectory()) {
      copyDir(from, to);
      continue;
    }
    cpSync(from, to);
  }
}

function runCargoMetadata(manifestPath: string): unknown {
  const result = spawnSync("cargo", ["metadata", "--format-version", "1", "--manifest-path", manifestPath], {
    encoding: "utf-8",
  });
  if (result.status !== 0) {
    fail(
      `cargo metadata failed for ${manifestPath}:\n${`${result.stdout ?? ""}${result.stderr ?? ""}`.trim()}`
    );
  }
  const raw = result.stdout;
  if (!raw) fail(`cargo metadata returned no output for ${manifestPath}.`);
  return JSON.parse(raw) as unknown;
}

export function runGenerate(opts: GenerateOptions): void {
  const absManifest = resolve(opts.manifestPath);
  const outDir = resolve(opts.outDir);
  const metadata = runCargoMetadata(absManifest) as {
    readonly packages?: readonly {
      readonly name: string;
      readonly version: string;
      readonly manifest_path: string;
      readonly targets?: readonly { readonly name: string; readonly kind?: readonly string[] }[];
    }[];
  };
  const pkg = metadata.packages?.find((entry) => resolve(entry.manifest_path) === absManifest);
  if (!pkg) fail(`Could not find package for manifest ${absManifest} in cargo metadata output.`);

  const libTarget = (pkg.targets ?? []).find((target) =>
    (target.kind ?? []).includes("lib")
  );
  if (!libTarget) fail(`Could not find a lib target in manifest ${absManifest}.`);
  const crateName = libTarget.name;
  const chosenPackageName = opts.packageName ?? `@tsuba/${pkg.name}`;
  const version = pkg.version;

  rmSync(outDir, { recursive: true, force: true });
  ensureDir(outDir);

  const modules = collectModules(absManifest);
  attachMethods(modules);
  applyReexports(modules);
  const skipIssues = collectSkipIssues(modules, dirname(absManifest));
  const stableSymbols = collectStableSymbols(modules, crateName);

  const moduleEntries: { spec: string; jsName: string; rustPath: string; dtsName: string }[] = [];
  for (const module of modules) {
    const jsName = moduleJsName(module.moduleParts);
    const dtsName = moduleDtsName(module.moduleParts);
    moduleEntries.push({
      spec: moduleSpecifier(chosenPackageName, module.moduleParts),
      jsName,
      rustPath: rustPath(crateName, module.moduleParts),
      dtsName,
    });
  }
  moduleEntries.sort((a, b) => compareText(a.spec, b.spec));

  for (const entry of moduleEntries) {
    const outJs = join(outDir, entry.jsName);
    const outDts = join(outDir, entry.dtsName);
    const module = moduleForRustPath(modules, crateName, entry.rustPath);
    ensureDir(dirname(outDts));
    writeFileSync(outJs, MANIFEST_TEMPLATE, "utf-8");
    writeFileSync(outDts, emitDts(module), "utf-8");
  }

  const modulesMap: Record<string, string> = {};
  for (const entry of moduleEntries) modulesMap[entry.spec] = entry.rustPath;
  const manifest: GenerateBindings = buildBindingsManifest({
    crateName,
    cratePackage: pkg.name,
    crateVersion: version,
    bundleCrate: opts.bundleCrate,
    modulesMap,
    stableSymbols,
  });
  writeFileSync(join(outDir, "tsuba.bindings.json"), `${JSON.stringify(manifest, null, 2)}\n`, "utf-8");

  const entryPaths = moduleEntries.map((entry) => entry.jsName).sort((a, b) => compareText(a, b));
  writeFileSync(join(outDir, "package.json"), makePackageJson(chosenPackageName, version, entryPaths), "utf-8");
  writeFileSync(join(outDir, "README.md"), `# ${chosenPackageName}\n\nGenerated by tsubabindgen.\n`, "utf-8");
  writeFileSync(
    join(outDir, "tsubabindgen.report.json"),
    `${JSON.stringify({ schema: 1, skipped: skipIssues }, null, 2)}\n`,
    "utf-8"
  );

  if (opts.bundleCrate) {
    copyDir(dirname(absManifest), join(outDir, "crate"));
  }
}
